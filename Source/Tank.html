<!DOCTYPE>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
    <script type="text/javascript" src="Scripts/Core/jquery-1.8.3.js"></script>
</head>
<body>
    <canvas width="600" height="600" style="border: 2px solid #222222; background: #000000;" id="context"></canvas>

    <script type="text/javascript" language="javascript">

        var common = {
            direction: { up: "up", down: "down", left: "left", right: "right" },
            className: { player: "player", enemy1: "enemy1", enemy2: "enemy2" },
            extend: function () {
                var options, name, src, copy, copyIsArray, clone,
		        target = arguments[0] || {},
		        i = 1,
		        length = arguments.length,
		        deep = false;

                // Handle a deep copy situation
                if (typeof target === "boolean") {
                    deep = target;
                    target = arguments[1] || {};
                    // skip the boolean and the target
                    i = 2;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if (typeof target !== "object" && !jQuery.isFunction(target)) {
                    target = {};
                }

                // extend jQuery itself if only one argument is passed
                if (length === i) {
                    target = this;
                    --i;
                }

                for (; i < length; i++) {
                    // Only deal with non-null/undefined values
                    if ((options = arguments[i]) != null) {
                        // Extend the base object
                        for (name in options) {
                            src = target[name];
                            copy = options[name];

                            // Prevent never-ending loop
                            if (target === copy) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray(src) ? src : [];

                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[name] = jQuery.extend(deep, clone, copy);

                                // Don't bring in undefined values
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            },
            noop: function () { alert("Not Imp"); }
        };

        var ClassFactory = {
            createClass: function (className, base, properties) {

                var newClass = function () { };
                newClass.properties = {};
                newClass.methods = newClass.prototype;
                newClass.className = className;
                newClass.base = base || {};

                if (base) {
                    common.extend(true, newClass.properties, base.properties);
                    common.extend(true, newClass.methods, base.methods);
                }

                if (properties) {
                    for (var key in properties) {
                        if (properties.hasOwnProperty(key)) {
                            if (properties[key] != null && properties[key].constructor == Function) {
                                newClass.methods[key] = properties[key];
                            }
                            else {
                                newClass.properties[key] = properties[key];
                            }
                        }
                    }
                }

                newClass.createNew = function (properties) {

                    var newInstance = new this();
                    newInstance.base = this.base.methods;
                    common.extend(true, newInstance, this.properties);

                    if (properties) {
                        var params = {};
                        for (var key in this.properties) {
                            if (properties.hasOwnProperty(key)) {
                                params[key] = properties[key];
                            }
                        }
                        common.extend(true, newInstance, params);
                    }

                    newInstance.class = this;
                    newInstance.className = this.className;

                    return newInstance;
                };

                newClass.addProperties = function (properties) {
                    common.extend(true, this.properties, properties);
                };

                newClass.addMethods = function(methods) {
                    common.extend(true, this.methods, methods);
                };

                newClass.methods.isInstancceOf = function (type) {
                    var base = this.class;
                    var isInstance = false;
                    while (base) {
                        if (base == type) {
                            isInstance = true;
                            break;
                        }
                        base = base.base;
                    }
                    return isInstance;
                };

                return newClass;
            }
        };

        var context = $("#context")[0].getContext("2d");

        var Graph = ClassFactory.createClass("Graph", null, {
            context: null,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            image: null,
            children: [],
            draw: function () {
                for (var i = 0; i < this.children.length; i++) {
                    if (this.children[i].deleted) {
                        this.remove(this.children[i]);
                        break;
                    }
                    else {
                        this.children[i].draw();
                    }
                }
            },
            add: function (graph) {
                if (graph.draw && graph.draw.constructor == Function) {
                    graph.context = this.context;
                    this.children.push(graph);
                }
            },
            remove: function (graph) {
                var i = 0;
                for (; i < this.children.length; i++) {
                    if (this.children[i] == graph) {
                        break;
                    }
                }
                this.children.splice(i, 1);
            },
            getChild: function (index) {
                if (index < 0 || index > this.children.length) {
                    alert("Out of Range");
                }
                return this.children[index];
            },
            clear: function () {
                this.context.clearRect(this.x, this.y, this.width, this.height);
            },
            deleted: false
        });

        var Mover = ClassFactory.createClass("Mover", Graph, {
            stage: null,
            speed: 0,
            direction: null,
            move: common.noop,
            draw: common.noop,
            hit: function () {
                var stage = this.stage;
                var direction = this.direction;
                var other = null;
                for (var i = 0; i < stage.children.length; i++) {
                    var graph = stage.children[i];
                    if (this == graph) {
                        continue;
                    }
                    if (direction == common.direction.up) {
                        if (this.y > (graph.y + graph.height) && this.y < (graph.y + graph.height + 10)) {
                            if ((this.x + this.width > graph.x) && (this.x + this.width <= graph.x + graph.width)) {
                                other = graph;
                                break;
                            }
                            if (this.x >= graph.x && (this.x <= graph.x + graph.width)) {
                                other = graph;
                                break;
                            }
                            if (this.x <= graph.x && (this.x + this.width >= graph.x + graph.width)) {
                                other = graph;
                                break;
                            }
                            if (this.x >= graph.x && (this.x + this.width <= graph.x + graph.width)) {
                                other = graph;
                                break;
                            }
                        }
                    }
                    else if (direction == common.direction.down) {
                        if ((this.y + this.height < graph.y) && (this.y + this.height > graph.y - 10)) {
                            if ((this.x + this.width > graph.x) && (this.x + this.width <= graph.x + graph.width)) {
                                other = graph;
                                break;
                            }
                            if (this.x >= graph.x && (this.x <= graph.x + graph.width)) {
                                other = graph;
                                break;
                            }
                            if (this.x <= graph.x && (this.x + this.width >= graph.x + graph.width)) {
                                other = graph;
                                break;
                            }
                            if (this.x >= graph.x && (this.x + this.width <= graph.x + graph.width)) {
                                other = graph;
                                break;
                            }
                        }
                    }
                    else if (direction == common.direction.left) {
                        if ((this.x > graph.x + graph.width) && (this.x < graph.x + graph.width + 10)) {
                            if ((this.y + this.height > graph.y) && (this.y + this.height <= graph.y + graph.height)) {
                                other = graph;
                                break;
                            }
                            if (this.y >= graph.y && (this.y <= graph.y + graph.height)) {
                                other = graph;
                                break;
                            }
                            if (this.y <= graph.y && (this.y + this.height >= graph.y + graph.height)) {
                                other = graph;
                                break;
                            }
                            if (this.y >= graph.y && (this.y + this.height <= graph.y + graph.height)) {
                                other = graph;
                                break;
                            }
                        }
                    }
                    else if (direction == common.direction.right) {
                        if ((this.x + this.width < graph.x) && (this.x + this.width > graph.x - 10)) {
                            if ((this.y + this.height > graph.y) && (this.y + this.height <= graph.y + graph.height)) {
                                other = graph;
                                break;
                            }
                            if (this.y >= graph.y && (this.y <= graph.y + graph.height)) {
                                other = graph;
                                break;
                            }
                            if (this.y <= graph.y && (this.y + this.height >= graph.y + graph.height)) {
                                other = graph;
                                break;
                            }
                            if (this.y >= graph.y && (this.y + this.height <= graph.y + graph.height)) {
                                other = graph;
                                break;
                            }
                        }
                    }
                }
                return other;
            }
        });

        var Fixed = ClassFactory.createClass("Fixed", Graph, {
            xCount: 0,
            yCount: 0,
            smallWidth: 0,
            smallHeight: 0,
            draw: function () {
                var fixed = this;
                var image = new Image();
                image.src = fixed.image;
                image.onload = function() {
                    for (var i = 0; i < fixed.xCount; i++) {
                        for (var j = 0; j < fixed.yCount; j++) {
                            fixed.context.drawImage(image, fixed.x + i * fixed.smallWidth, fixed.y + j * fixed.smallHeight, fixed.smallWidth, fixed.smallHeight);
                        }
                    }
                    image = null;
                };
            }
        });

        var Missile = ClassFactory.createClass("Missile", Mover, {
            width: 17,
            height: 17,
            shootLength: 200,
            moveLength: 0,
            speed: 6,
            shooting: false,
            tank: null,
            shoot: function () {
                var missile = this;
                var tank = missile.tank;
                missile.deleted = false;
                if (missile.shooting) {
                    return;
                }

                switch (tank.direction) {
                    case common.direction.up:
                        missile.x = tank.x + Math.ceil((tank.width - missile.width) / 2);
                        missile.y = tank.y - missile.height;
                        missile.direction = common.direction.up;
                        missile.move = function () {
                            this.y -= this.speed;
                        };
                        break;
                    case common.direction.down:
                        missile.x = tank.x + Math.ceil((tank.width - missile.width) / 2);
                        missile.y = tank.y + tank.height;
                        missile.direction = common.direction.down;
                        missile.move = function () {
                            this.y += this.speed;
                        };
                        break;
                    case common.direction.left:
                        missile.x = tank.x - missile.width;
                        missile.y = tank.y + Math.ceil((tank.height - missile.height) / 2);
                        missile.direction = common.direction.left;
                        missile.move = function () {
                            this.x -= this.speed;
                        };
                        break;
                    case common.direction.right:
                        missile.x = tank.x + tank.width;
                        missile.y = tank.y + Math.ceil((tank.height - missile.height) / 2);
                        missile.direction = common.direction.right;
                        missile.move = function () {
                            this.x += this.speed;
                        };
                        break;
                    default:
                        break;
                }

                tank.stage.add(missile);
                missile.shooting = true;
            },
            draw: function () {
                var missile = this;
                missile.clear();
                missile.move();
                missile.moveLength += missile.speed;
                if (missile.moveLength <= missile.shootLength) {
                    var hit = missile.hit();
                    if (hit) {
                        hit.deleted = true;
                        missile.deleted = true;
                        missile.shooting = false;
                        missile.moveLength = 0;
                        return;
                    }

                    var image = new Image();
                    image.src = missile.image;
                    image.onload = function () {
                        missile.context.drawImage(image, missile.x, missile.y, missile.width, missile.height);
                        image = null;
                    };
                }
                else {
                    missile.deleted = true;
                    missile.shooting = false;
                    missile.moveLength = 0;
                }
            },
            clone: function () {
                var newMissile = Missile.createNew();
                common.extend(true, newMissile, this);
                return newMissile;
            }
        });

        var Tank = ClassFactory.createClass("Tank", Mover, {
            step: 0,
            missile: Missile.createNew({
                image: "Images/enemymissile.png"
            }),
            imageDictionary: { up: "", down: "", left: "", right: "" },
            setMissile: function (missile) {
                missile.tank = this;
                missile.context = this.context;
                missile.stage = this.stage;
                this.missile = missile;
            },
            shoot: function () {
                this.missile.shoot();
            },
            moveRandom: function () {
                var random = Math.round(Math.random() * 3);
                var nextDirection = ["up", "down", "left", "right"][random];
                var dict = { up: "moveUp", down: "moveDown", left: "moveLeft", right: "moveRight" };
                if (!this.direction) {
                    this.direction = nextDirection;
                    ++this.step;
                    this[dict[this.direction]]();
                }
                else {
                    if (++this.step == 15) {
                        this.direction = nextDirection;
                        this.step = 0;
                        if (Math.random() * 100 > 50) {
                            if (Math.random() * 100 > 50) {
                                this.shoot();
                            }
                        }
                    }
                    this[dict[this.direction]]();
                }
            },
            moveUp: function () {
                this.move = function () {
                    this.direction = common.direction.up;
                    var hit = this.hit();
                    if (!hit) {
                        this.y -= this.image == this.imageDictionary.up ? this.speed : 0;
                        this.y = this.y <= 0 ? 0 : this.y;
                    }
                    this.image = this.imageDictionary.up;
                };
            },
            moveDown: function () {
                this.move = function () {
                    this.direction = common.direction.down;
                    var hit = this.hit();
                    if (!hit) {
                        this.y += this.image == this.imageDictionary.down ? this.speed : 0;
                        this.y = (this.y + this.height >= this.stage.height) ? (this.stage.height - this.height) : this.y;
                    }
                    this.image = this.imageDictionary.down;
                };
            },
            moveLeft: function () {
                this.move = function () {
                    this.direction = common.direction.left;
                    var hit = this.hit();
                    if (!hit) {
                        this.x -= this.image == this.imageDictionary.left ? this.speed : 0;
                        this.x = this.x <= 0 ? 0 : this.x;
                    }
                    this.image = this.imageDictionary.left;
                };
            },
            moveRight: function () {
                this.move = function() {
                    this.direction = common.direction.right;
                    var hit = this.hit();
                    if (!hit) {
                        this.x += this.image == this.imageDictionary.right ? this.speed : 0;
                        this.x = (this.x + this.width) >= this.stage.width ? (this.stage.width - this.width) : this.x;
                    }
                    this.image = this.imageDictionary.right;
                };
            },
            draw: function () {
                var tank = this;
                tank.clear();
                if (tank.deleted) {
                    return;
                }
                if (tank.move != common.noop) {
                    tank.move();
                    tank.move = common.noop;
                }
                var image = new Image();
                image.src = tank.imageDictionary[tank.direction];
                image.onload = function () {
                    if (!tank.deleted) {
                        tank.context.drawImage(image, tank.x, tank.y, tank.width, tank.height);
                    }
                    image = null;
                };
            },
            clone: function () {
                var newTank = Tank.createNew();
                common.extend(true, newTank, this);
                return newTank;
            }
        });

        var Stage = ClassFactory.createClass("Stage", Graph, {
            context: context,
            player: null,
            enemies: [],
            addEnemy: function (enemy) {
                this.add(enemy);
                this.enemies.push(enemy);
                enemy.stage = this;
            },
            removeEnemy: function (enemy) {
                var i = 0;
                for (; i < this.enemies.length; i++) {
                    if (this.enemies[i] == enemy) {
                        break;
                    }
                }
                this.enemies.splice(i, 1);
            },
            setPlayer: function (player) {
                this.add(player);
                this.player = player;
                player.stage = this;
            },
            start: function () {
                this.draw();
                var stage = this;
                $(document).on("keydown", function (e) {
                    switch (e.which) {
                        case 32:
                            stage.player.shoot();
                            break;
                        case 37:
                            stage.player.moveLeft();
                            break;
                        case 38:
                            stage.player.moveUp();
                            break;
                        case 39:
                            stage.player.moveRight();
                            break;
                        case 40:
                            stage.player.moveDown();
                            break;
                        default:
                            break;
                    }
                    return false;
                });

                var fps = 1000 / 30;
                var timer = setInterval(function () {
                    for (var i = 0; i < stage.enemies.length; i++) {
                        stage.enemies[i].moveRandom();
                    }
                    for (var i = 0; i < stage.children.length; i++) {
                        stage.children[i].draw();
                    }
                    var newArr = [];
                    for (var i = 0; i < stage.children.length; i++) {
                        if (!stage.children[i].deleted) {
                            newArr.push(stage.children[i]);
                        }
                        else {
                            stage.removeEnemy(stage.children[i]);
                        }
                    }
                    stage.children = newArr;

                    if (stage.enemies.length == 0) {
                        clearInterval(timer);
                        alert("胜利");
                    }

                }, fps);
            }
        });

        var Game = ClassFactory.createClass("Game", null, {});

        var ColliderManager = ClassFactory.createClass("Game", null, {
            graphes: [],
            collideCommands: [],
            add: function (collideCommand) {
                collideCommands.push(collderCommand);
            },
            remove: function () {
            },
            checkCollide: function (mover) {
                var temp = null;
                for (var i = 0; i < this.graphes.length; i++) {
                    var tester = this.graphes[i];
                    if (tester == mover) {
                        continue;
                    }
                    if (Math.abs(mover.x - tester.x) <= (mover.x > tester.x ? tester.width : mover.width)) {
                        break;
                    }
                    if (Math.abs(mover.x - tester.x) <= (mover.y > tester.y ? tester.height : mover.height)) {
                        break;
                    }
                }
            }
        });

        var ColliderCommand = ClassFactory.createClass("ColliderCommand", null, {
            execute: function (collider, collidee) { }
        });

        var TankMissileColliderCommand = ClassFactory.createClass("TankMissileCollider", ColliderCommand, {
            execute: function (collider, collidee) {
                var tank = collider.class == Tank ? collider : collidee;
                var missile = collider.class == Missile ? collider : collidee;

                if (missile.tank == tank) {
                    return;
                }

                if (Math.abs(tank.x - missile.x) <= (tank.x > missile.x ? missile.width : tank.width)) {

                }
                if (Math.abs(tank.x - missile.x) <= (tank.y > missile.y ? missile.height : tank.height)) {
                    tank.clear();
                }
                tank.deleted = true;
            }
        });
        var context = context;

        var BoundaryCollideCommand = ClassFactory.createClass("BoundaryCollideCommand", ColliderCommand, {
            execute: function (collider, collidee) {
                var boundary = collider;
                var mover = collidee;

                if (Math.abs(boundary.x - mover.x) <= (tank.x > missile.x ? missile.width : tank.width)) {

                }
                if (Math.abs(tank.x - missile.x) <= (tank.y > missile.y ? missile.height : tank.height)) {
                    tank.clear();
                }
                tank.deleted = true;
            }
        });

        var stage = Stage.createNew({
            context: context,
            width: 600,
            height: 600
        });
        var player = Tank.createNew({
            direction: common.direction.up,
            imageDictionary: { up: "Images/p1tankU.png", down: "Images/p1tankD.png", left: "Images/p1tankL.png", right: "Images/p1tankR.png" },
            x: 260,
            y: 570,
            width: 30,
            height: 30,
            speed: 4
        });
        var enemy1 = Tank.createNew({
            direction: common.direction.down,
            imageDictionary: { up: "Images/enemy1U.png", down: "Images/enemy1D.png", left: "Images/enemy1L.png", right: "Images/enemy1R.png" },
            x: 0,
            y: 0,
            width: 30,
            height: 30,
            speed: 4
        });
        var enemy2 = Tank.createNew({
            direction: common.direction.down,
            imageDictionary: { up: "Images/enemy2U.png", down: "Images/enemy2D.png", left: "Images/enemy2L.png", right: "Images/enemy2R.png" },
            x: 260,
            y: 500,
            width: 30,
            height: 30,
            speed: 5
        });
        var enemy3 = Tank.createNew({
            direction: common.direction.down,
            imageDictionary: { up: "Images/enemy3U.png", down: "Images/enemy3D.png", left: "Images/enemy3L.png", right: "Images/enemy3R.png" },
            x: 400,
            y: 570,
            width: 30,
            height: 30,
            speed: 3
        });
        
        var missile1 = Missile.createNew({
            image: "Images/tankmissile.png"
        });
        var missile2 = Missile.createNew({
            image: "Images/enemymissile.png"
        });
        stage.setPlayer(player);
        stage.addEnemy(enemy1);
        stage.addEnemy(enemy2);
        stage.addEnemy(enemy3);
        player.setMissile(missile1);
        enemy1.setMissile(missile2);
        enemy2.setMissile(missile2.clone());
        enemy3.setMissile(missile2.clone());
        stage.start();

        var player2 = Tank.createNew({
            stage: stage,
            context: context,
            direction: common.direction.up,
            imageDictionary: { up: "Images/p1tankU.png", down: "Images/p1tankD.png", left: "Images/p1tankL.png", right: "Images/p1tankR.png" },
            x: 100,
            y: 500,
            width: 30,
            height: 30,
            speed: 4
        });
        
    </script>

</body>
</html>
